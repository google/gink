syntax = "proto3";
import "values.proto";
import "muid.proto";
package google.gink;

message Obj {
    oneof body {
        Node node = 1;
        Entry entry = 2;
        Exit exit = 3;
        Title title = 4;
        Property property = 5;
        Metadata metadata = 6;
        NodeKind node_kind = 8;
        EdgeKind edge_kind = 9;
    }
}

message Property {
    ValueSpec value_spec = 1;
}

message NodeKind {
    Muid extends = 1;
}

message EdgeKind {
    // designated exclusivity from source, e.g. an employee can have 
    // only one manager but a manager can have multiple reports.
    bool exclusive = 1;
    repeated Muid src_node_kinds = 2;
    repeated Muid dst_node_kinds = 3;
}

message Title {
    Muid describes = 1;
    string title = 2;
}

message Metadata {
    Muid describes = 1; // the id of a node entry
    Muid property = 2; // the id of a property
    Value value = 3;  // must adhere to the property's value spec if present
}

message Node {
    enum Behavior {
        UNKNOWN = 0;
        ACTYPE = 1;
        PROTO2 = 2;
        PROTO3 = 3;
        TABLE = 5;
        INDEX = 6;
        VIEW = 7;
        QUEUE = 8;
        SCHEMA = 9;
        BOX = 10;
        FILE = 11;
        BINLOG = 12;
        SET = 13;
        ENUM = 14;
        SUM = 15;
    }
    oneof contents {
        Muid node_kind = 1;
        Behavior behavior = 2;
    }
    Muid extends = 3; // inheritance (for TABLE,QUEUE,SCHEMA,PROTO,ACTYPE)
    oneof spec { // can be used with a behavior or to describe/limit entries 
        ValueSpec value_spec = 4;
        RowSpec row_spec = 5;
    }
    ValueSpec key_spec = 6; // only when behavior = SCHEMA
    bool allow_resets = 7; // may require storing entries between resets (e.g. for SUM)
}


message Entry {
    Muid src_node = 1; // not present for "root" entry

    message Span {
        uint64 from=1;
        uint64 ends=2;
    }
    oneof link {
        // For behavior in {BOX, QUEUE, ACTYPE, TABLE, BINLOG} there is no link.
        // This includes when setting the root entry (i.e. no src_node).
        Value key = 2;      // only for src_node behavior in {SCHEMA, SET}
        Muid edge_kind = 3; // only when src_node has a node_kind
        Span span = 4;      // only for src_node behavior = FILE
    }
    oneof destination {
        Muid dst_node = 5;
        bool deleting = 6; // serves as reset when no link is set
        uint64 medallion = 7; // follow the root entry of another db instance
        bytes octects = 8; // for src_node behavior in {FILE, BINLOG}
        Value value = 9;
        Row row = 10; // only when src_node has row_spec (TABLE or ACTYPE)
    }
    uint64 expiry = 11; // timestamp of expiration in microseconds since epoch
    bytes iv = 15; // initialization vector when octects are encrypted
    bytes key_id = 16; // optional hint of which key was used (when encrypted)
}

/**
    An "Exit" acts to remove an Entry.  After seeing an Exit pointing to
    an Entry, the system should act as though that Entry no longer exists.
    An expiry set on an Exit makes this removal temporary.  One use case is
    to temporarily remove an item from a work queue to start processing it,
    then permanently remove it once processing has been completed.
    To remove keys from a schema, adding a new Entry with deleting=True 
    is generally better (otherwise prior Entries with earlier timestamps
    will appear to be in effect).  When the effect Muid is set that indicates
    that the specified Effect has been processed (it not a general deletion).
*/
message Exit {
    Muid entry = 1;
    uint64 expiry = 2;
    Muid effect = 3;
}
